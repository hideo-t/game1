<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>インベーダーゲーム（SFX+Alien / iPad音確実版）</title>
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0;
      background:#070b14;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      min-height:100svh;
      display:grid;
      place-items:center;
      padding:12px;
    }
    .wrap{ width:min(760px,100%); }
    .hud{
      display:flex;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      gap:8px;
      color:#d7e1ff;
      margin:8px 2px 10px;
    }
    .left{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      padding:6px 10px;
      border-radius:999px;
      font-size:14px;
    }
    .btn{
      cursor:pointer;
      user-select:none;
      background:rgba(140,220,255,.18);
      border:1px solid rgba(140,220,255,.35);
      color:#eaf6ff;
      padding:8px 12px;
      border-radius:10px;
      font-weight:900;
    }
    .btn:active{ transform:translateY(1px); }

    canvas{
      width:100%;
      height:auto;
      display:block;
      border-radius:16px;
      background:
        radial-gradient(1100px 500px at 50% 120%, rgba(120,200,255,.14), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.10);
      touch-action:none;
      outline:none;
    }
    .hint{
      color:rgba(215,225,255,.8);
      font-size:12px;
      margin-top:10px;
      line-height:1.6;
    }
    .kbd{
      padding:2px 6px;
      border-radius:6px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.12);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="left">
        <div class="pill">SCORE: <span id="score">0</span></div>
        <div class="pill">LIVES: <span id="lives">3</span></div>
        <div class="pill">WAVE: <span id="wave">1</span></div>
        <div class="pill">SFX: <span id="sfx">ON</span></div>
        <!-- ★ 追加：音アンロック用ボタン -->
        <button class="btn" id="btnSound" type="button">SOUND ON</button>
      </div>
      <button class="btn" id="btnRestart" type="button">RESTART</button>
    </div>

    <!-- ★ iPad Safari対策：tabindexでフォーカス可能にする -->
    <canvas id="game" width="760" height="520" tabindex="0"></canvas>

    <div class="hint">
      操作：<span class="kbd">←</span><span class="kbd">→</span> / <span class="kbd">A</span><span class="kbd">D</span>　
      <span class="kbd">Space</span>で発射　
      <span class="kbd">P</span>で一時停止　
      <span class="kbd">M</span>で効果音ON/OFF
      ｜ スマホ：指で左右に動かす（タップで発射）<br>
      ※ iPad Safari：音が出ない時は「SOUND ON」を1回押す（確実にアンロックする）
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const $score = document.getElementById("score");
  const $lives = document.getElementById("lives");
  const $wave  = document.getElementById("wave");
  const $sfx   = document.getElementById("sfx");
  const btnRestart = document.getElementById("btnRestart");
  const btnSound = document.getElementById("btnSound");

  const W = canvas.width, H = canvas.height;

  // =========================
  // SFX (Web Audio) 強化版
  // =========================
  const Audio = {
    ctx: null,
    enabled: true,
    unlocked: false,
    ensure(){
      if (!this.ctx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) return null;
        this.ctx = new AC();
      }
      return this.ctx;
    },
    async unlock(){
      if (!this.enabled) return;
      const ac = this.ensure();
      if (!ac) return;

      // iOS: gesture内でresumeが通ると強い
      try{
        if (ac.state !== "running") await ac.resume();
      }catch{}

      // 無音ワンショットで“確実に”アンロック
      try{
        const o = ac.createOscillator();
        const g = ac.createGain();
        g.gain.value = 0.00001; // ほぼ無音
        o.frequency.value = 440;
        o.connect(g); g.connect(ac.destination);
        o.start();
        o.stop(ac.currentTime + 0.01);
        this.unlocked = true;
      }catch{}
    },
    setEnabled(v){
      this.enabled = v;
      $sfx.textContent = v ? "ON" : "OFF";
    },
    async beep({freq=600, dur=0.06, type="square", gain=0.06, sweep=0} = {}){
      if (!this.enabled) return;
      const ac = this.ensure();
      if (!ac) return;

      // stateがrunningじゃないと鳴らないので、可能なら起こす
      if (ac.state !== "running") {
        try { await ac.resume(); } catch {}
        if (ac.state !== "running") return;
      }

      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = type;
      const t0 = ac.currentTime;

      o.frequency.setValueAtTime(freq, t0);
      if (sweep !== 0) o.frequency.linearRampToValueAtTime(freq + sweep, t0 + dur);

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.linearRampToValueAtTime(gain, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      o.connect(g);
      g.connect(ac.destination);
      o.start(t0);
      o.stop(t0 + dur);
    },
    shoot(){ this.beep({freq: 860, dur: 0.05, type:"square",   gain:0.05, sweep:-120}); },
    hit(){   this.beep({freq: 220, dur: 0.09, type:"sawtooth",  gain:0.06, sweep: 180}); },
    hurt(){  this.beep({freq: 120, dur: 0.14, type:"triangle",  gain:0.07, sweep:-40}); },
    step(){  this.beep({freq: 140, dur: 0.06, type:"square",    gain:0.02, sweep:  20}); }
  };
  Audio.setEnabled(true);

  // ★ SOUNDボタン：確実にアンロックして試し音を鳴らす
  btnSound.addEventListener("click", async () => {
    await Audio.unlock();
    await Audio.beep({freq: 520, dur: 0.08, type:"triangle", gain:0.06, sweep: 240});
    btnSound.textContent = "SOUND OK";
    setTimeout(()=>btnSound.textContent="SOUND ON", 1200);
    canvas.focus();
  });

  // =========================
  // State
  // =========================
  let score = 0;
  let lives = 3;
  let wave  = 1;

  let paused = false;
  let gameOver = false;

  const player = {
    w: 68, h: 16,
    x: (W - 68) / 2,
    y: H - 40,
    speed: 8.5,
    cooldown: 0,
    targetX: null
  };

  const bullets = [];
  const enemyBullets = [];
  const barriers = [];
  const sparks = [];

  let invaders = [];
  let invDir = 1;
  let invSpeed = 0.55;
  let invDrop = 18;
  let stepTimer = 0;
  let stepInterval = 0.55;

  const keys = new Set();

  function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

  window.addEventListener("keydown", async (e) => {
    const isSpace = (e.code === "Space") || (e.key === " ") || (e.key === "Spacebar");

    if (["ArrowLeft","ArrowRight","a","d","A","D","p","P","m","M"].includes(e.key) || isSpace) {
      e.preventDefault();
    }

    keys.add(e.key);

    if (e.key === "p" || e.key === "P") paused = !paused;
    if (e.key === "m" || e.key === "M") Audio.setEnabled(!Audio.enabled);

    // ★ iPad Safari：キーボード操作でも一応unlock試す（通らない時もある）
    await Audio.unlock();
    canvas.focus();

    if (isSpace && !paused) shoot();
  }, { passive:false });

  window.addEventListener("keyup", (e) => keys.delete(e.key));

  function pointerToCanvasX(clientX){
    const rect = canvas.getBoundingClientRect();
    return (clientX - rect.left) * (canvas.width / rect.width);
  }

  // ★ iOSは「touchstart」が最強のgestureなので必ずここでunlock
  canvas.addEventListener("touchstart", async () => {
    canvas.focus();
    await Audio.unlock();
  }, { passive:true });

  canvas.addEventListener("pointerdown", async (e) => {
    canvas.setPointerCapture(e.pointerId);
    canvas.focus();

    await Audio.unlock();

    player.targetX = pointerToCanvasX(e.clientX) - player.w/2;
    if (!paused) shoot();
  });

  canvas.addEventListener("pointermove", (e) => {
    if (e.pressure === 0 && e.pointerType !== "mouse") return;
    player.targetX = pointerToCanvasX(e.clientX) - player.w/2;
  });

  canvas.addEventListener("pointerup", () => player.targetX = null);

  btnRestart.addEventListener("click", async () => {
    reset(true);
    canvas.focus();
    await Audio.unlock();
  });

  function syncHUD(){
    $score.textContent = String(score);
    $lives.textContent = String(lives);
    $wave.textContent  = String(wave);
  }

  function reset(full){
    if (full){
      score = 0; lives = 3; wave = 1;
    }
    paused = false;
    gameOver = false;

    player.x = (W - player.w)/2;
    player.cooldown = 0;
    player.targetX = null;

    bullets.length = 0;
    enemyBullets.length = 0;
    sparks.length = 0;

    makeBarriers();
    makeInvaders();

    invDir = 1;
    invSpeed = 0.55 + (wave - 1) * 0.08;
    stepInterval = Math.max(0.22, 0.55 - (wave - 1) * 0.04);
    stepTimer = 0;

    syncHUD();
  }

  function makeInvaders(){
    invaders = [];
    const rows = 5, cols = 11;
    const padX = 42, top = 70, gap = 10;
    const iw = 38, ih = 26;

    for (let r=0; r<rows; r++){
      for (let c=0; c<cols; c++){
        const x = padX + c*(iw+gap);
        const y = top + r*(ih+gap);
        invaders.push({ x,y,w:iw,h:ih, alive:true, type:r, phase: Math.random()*Math.PI*2 });
      }
    }
  }

  function makeBarriers(){
    barriers.length = 0;
    const baseY = H - 120;
    const count = 4;
    const block = 6;
    const bw = 72, bh = 42;

    for (let i=0; i<count; i++){
      const cx = (W/(count+1))*(i+1);
      const startX = Math.floor(cx - bw/2);
      const startY = baseY;

      for (let y=0; y<bh; y+=block){
        for (let x=0; x<bw; x+=block){
          const gx = startX + x;
          const gy = startY + y;

          const mid = bw/2;
          const dx = Math.abs((x + block/2) - mid);
          const hole = (y > bh*0.55 && dx < bw*0.18) || (y > bh*0.75 && dx < bw*0.28);
          const topTrim = (y < block*2 && dx > bw*0.35);

          if (!hole && !topTrim){
            barriers.push({ x:gx, y:gy, w:block, h:block, hp:3 });
          }
        }
      }
    }
  }

  function shoot(){
    if (gameOver) return;
    if (player.cooldown > 0) return;
    if (bullets.length >= 3) return;

    bullets.push({ x: player.x + player.w/2, y: player.y - 6, r: 3.5, vy: -8.5 });
    player.cooldown = 10;

    Audio.shoot();
  }

  function circleRect(cx,cy,r, rx,ry,rw,rh){
    const nx = clamp(cx, rx, rx+rw);
    const ny = clamp(cy, ry, ry+rh);
    const dx = cx - nx, dy = cy - ny;
    return (dx*dx + dy*dy) <= r*r;
  }

  function invaderColor(type){
    return ["rgba(255,230,150,.95)","rgba(200,255,190,.95)","rgba(170,210,255,.95)","rgba(255,175,205,.95)","rgba(210,190,255,.95)"][type]
      || "rgba(200,230,255,.95)";
  }

  function explode(x,y,baseColor){
    const n = 18 + Math.floor(Math.random()*16);
    for (let i=0; i<n; i++){
      const a = Math.random()*Math.PI*2;
      const sp = 90 + Math.random()*260;
      sparks.push({
        x,y,
        vx: Math.cos(a)*sp,
        vy: Math.sin(a)*sp,
        r: 1.6 + Math.random()*3.2,
        t: 0,
        life: 0.35 + Math.random()*0.35,
        color: baseColor
      });
    }
  }

  function fireEnemyBullet(){
    const cols = new Map();
    for (const inv of invaders){
      if (!inv.alive) continue;
      const key = Math.round(inv.x / 10);
      const cur = cols.get(key);
      if (!cur || inv.y > cur.y) cols.set(key, inv);
    }
    const shooters = Array.from(cols.values());
    if (shooters.length === 0) return;

    shooters.sort((a,b) =>
      Math.abs((a.x+a.w/2) - (player.x+player.w/2)) -
      Math.abs((b.x+b.w/2) - (player.x+player.w/2))
    );
    const pick = shooters[Math.random() < 0.65 ? 0 : Math.floor(Math.random()*shooters.length)];

    enemyBullets.push({ x: pick.x + pick.w/2, y: pick.y + pick.h + 4, r: 4, vy: 6.2 + (wave-1)*0.25 });
  }

  function drawAlien(x, y, w, h, type, phase){
    const cols = 8, rows = 6;
    const cw = w / cols, ch = h / rows;

    const sprites = [
      ["00111100","01111110","11100111","11111111","01011010","10100101"],
      ["00111100","01111110","11111111","11011011","01111110","01000010"],
      ["00011000","01111110","11111111","10111101","00111100","01011010"],
      ["00111100","11111111","11011011","11111111","00100100","01000010"],
      ["01111110","11111111","11000011","11111111","01111110","00100100"],
    ];
    const spr = sprites[type] || sprites[2];

    ctx.fillStyle = invaderColor(type);
    for (let r=0;r<rows;r++){
      const line = spr[r];
      for (let c=0;c<cols;c++){
        if (line[c] === "1"){
          ctx.fillRect(x + c*cw, y + r*ch, cw+0.2, ch+0.2);
        }
      }
    }

    const blink = 0.5 + 0.5*Math.sin(phase);
    ctx.fillStyle = `rgba(0,0,0,${0.25 + 0.25*blink})`;
    ctx.fillRect(x + w*0.28, y + h*0.28, w*0.12, h*0.12);
    ctx.fillRect(x + w*0.60, y + h*0.28, w*0.12, h*0.12);

    ctx.fillStyle = `rgba(255,255,255,${0.25 + 0.35*blink})`;
    ctx.fillRect(x + w*0.30, y + h*0.30, w*0.05, h*0.05);
    ctx.fillRect(x + w*0.62, y + h*0.30, w*0.05, h*0.05);
  }

  function update(dt){
    if (paused) return;

    let dir = 0;
    if (keys.has("ArrowLeft") || keys.has("a") || keys.has("A")) dir -= 1;
    if (keys.has("ArrowRight")|| keys.has("d") || keys.has("D")) dir += 1;

    if (player.targetX !== null){
      player.x += (player.targetX - player.x) * 0.22;
    } else {
      player.x += dir * player.speed * dt * 60;
    }
    player.x = clamp(player.x, 10, W - player.w - 10);
    player.cooldown = Math.max(0, player.cooldown - dt*60);

    stepTimer += dt;
    if (stepTimer >= stepInterval){
      stepTimer = 0;

      let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
      let aliveCount = 0;
      for (const inv of invaders){
        if (!inv.alive) continue;
        aliveCount++;
        minX = Math.min(minX, inv.x);
        maxX = Math.max(maxX, inv.x + inv.w);
        maxY = Math.max(maxY, inv.y + inv.h);
      }

      if (aliveCount === 0){
        wave++;
        bullets.length = 0;
        enemyBullets.length = 0;
        sparks.length = 0;
        makeBarriers();
        makeInvaders();
        invDir = 1;
        invSpeed = 0.55 + (wave - 1) * 0.08;
        stepInterval = Math.max(0.20, 0.55 - (wave - 1) * 0.04);
        syncHUD();
        return;
      }

      const nextMin = minX + invDir * invSpeed * 28;
      const nextMax = maxX + invDir * invSpeed * 28;

      if (nextMin <= 14 || nextMax >= W - 14){
        invDir *= -1;
        for (const inv of invaders){ if (inv.alive) inv.y += invDrop; }
        invSpeed = Math.min(1.8, invSpeed + 0.06);
      } else {
        for (const inv of invaders){
          if (inv.alive) { inv.x += invDir * invSpeed * 28; inv.phase += 0.6; }
        }
      }

      Audio.step();

      const fireChance = clamp(0.08 + (1 - aliveCount/55) * 0.28 + (wave-1)*0.02, 0.08, 0.5);
      if (Math.random() < fireChance) fireEnemyBullet();

      if (maxY >= player.y - 6) gameOver = true;
    }

    for (let i=bullets.length-1; i>=0; i--){
      const b = bullets[i];
      b.y += b.vy * dt * 60;
      if (b.y < -20){ bullets.splice(i,1); continue; }

      let hitBarrier = false;
      for (let j=barriers.length-1; j>=0; j--){
        const bb = barriers[j];
        if (circleRect(b.x, b.y, b.r, bb.x, bb.y, bb.w, bb.h)){
          bb.hp -= 1;
          bullets.splice(i,1);
          hitBarrier = true;
          if (bb.hp <= 0) barriers.splice(j,1);
          break;
        }
      }
      if (hitBarrier) continue;

      for (const inv of invaders){
        if (!inv.alive) continue;
        if (circleRect(b.x, b.y, b.r, inv.x, inv.y, inv.w, inv.h)){
          inv.alive = false;
          bullets.splice(i,1);

          score += [60,45,35,25,15][inv.type] ?? 15;
          syncHUD();

          explode(inv.x + inv.w/2, inv.y + inv.h/2, invaderColor(inv.type));
          Audio.hit();

          invSpeed = Math.min(2.2, invSpeed + 0.015);
          stepInterval = Math.max(0.16, stepInterval - 0.004);
          break;
        }
      }
    }

    for (let i=enemyBullets.length-1; i>=0; i--){
      const b = enemyBullets[i];
      b.y += b.vy * dt * 60;
      if (b.y > H + 30){ enemyBullets.splice(i,1); continue; }

      let hitBarrier = false;
      for (let j=barriers.length-1; j>=0; j--){
        const bb = barriers[j];
        if (circleRect(b.x, b.y, b.r, bb.x, bb.y, bb.w, bb.h)){
          bb.hp -= 1;
          enemyBullets.splice(i,1);
          hitBarrier = true;
          if (bb.hp <= 0) barriers.splice(j,1);
          break;
        }
      }
      if (hitBarrier) continue;

      if (circleRect(b.x, b.y, b.r, player.x, player.y, player.w, player.h)){
        enemyBullets.splice(i,1);
        lives -= 1;
        syncHUD();
        Audio.hurt();
        explode(player.x + player.w/2, player.y + player.h/2, "rgba(255,120,140,.95)");
        if (lives <= 0){ lives = 0; gameOver = true; }
      }
    }

    for (let i=sparks.length-1; i>=0; i--){
      const p = sparks[i];
      p.t += dt;
      if (p.t >= p.life){ sparks.splice(i,1); continue; }
      p.vy += 420 * dt;
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= (1 - dt*2.0);
      p.vy *= (1 - dt*1.2);
    }
  }

  function roundRect(x,y,w,h,r,fill=false){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y, x+w,y+h, rr);
    ctx.arcTo(x+w,y+h, x,y+h, rr);
    ctx.arcTo(x,y+h, x,y, rr);
    ctx.arcTo(x,y, x+w,y, rr);
    ctx.closePath();
    if (fill) ctx.fill();
  }

  function centerText(text,y,size,color){
    ctx.fillStyle = color;
    ctx.font = `900 ${size}px system-ui, -apple-system, "Noto Sans JP", sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, W/2, y);
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    ctx.globalAlpha = 0.22;
    for (let i=0;i<90;i++){
      const x = (i*97) % W;
      const y = (i*157) % H;
      ctx.fillStyle = "white";
      ctx.fillRect(x,y,1,1);
    }
    ctx.globalAlpha = 1;

    for (const b of barriers){
      const a = b.hp === 3 ? 0.95 : (b.hp === 2 ? 0.72 : 0.48);
      ctx.fillStyle = `rgba(160,255,200,${a})`;
      ctx.fillRect(b.x, b.y, b.w, b.h);
    }

    ctx.fillStyle = "rgba(240,246,255,.95)";
    roundRect(player.x, player.y, player.w, player.h, 8, true);

    for (const inv of invaders){
      if (!inv.alive) continue;
      drawAlien(inv.x, inv.y, inv.w, inv.h, inv.type, inv.phase);
    }

    for (const b of bullets){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,255,255,.95)";
      ctx.fill();
    }

    for (const b of enemyBullets){
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,120,140,.9)";
      ctx.fill();
    }

    for (const p of sparks){
      const a = 1 - (p.t / p.life);
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fillStyle = p.color.replace(/\d?\.?\d+\)\s*$/, `${0.85*a})`);
      ctx.fill();
    }

    if (paused && !gameOver){
      centerText("PAUSED (Pで再開)", H*0.55, 20, "rgba(215,225,255,.9)");
    }
    if (gameOver){
      centerText("GAME OVER", H*0.52, 28, "rgba(255,220,220,.95)");
      centerText("RESTARTでやり直し", H*0.62, 14, "rgba(215,225,255,.75)");
    }
  }

  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  reset(true);
  try{ canvas.focus(); }catch{}
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>